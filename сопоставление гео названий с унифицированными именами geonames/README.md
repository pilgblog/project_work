# Сопоставление гео названий с унифицированными именами geonames
## Заказчик: Карьерный центр Яндекс Практикум
## тип занятости: проектная занятость

## Цель проекта:
Cоздать решение для сопоставления гео названий с унифицированными именами geonames для внутреннего использования Карьерным центром Яндекс Практикум
## Бизнес-задача pet-проекта:
- Создать решение для подбора наиболее подходящих названий с geonames. Например Ереван -> Yerevan
- На примере РФ и стран наиболее популярных для релокации - Беларусь, Армения, Казахстан, Кыргызстан, Турция, Сербия. Города с населением от 15000 человек (с возможностью масштабирования на сервере заказчика)
- Возвращаемые поля geonameid, name, region, country, cosine similarity
- формат данных на выходе: список словарей, например [{dict_1}, {dict_2}, …. {dict_n}] где словарь - одна запись с указанными полями

## Для решения задач проекта, произведено несколько этапов:
<ul><h3>Этап 1</h3>
<li><a href='https://github.com/pilgblog/project_work/blob/main/сопоставление%20гео%20названий%20с%20унифицированными%20именами%20geonames/work_postgres_geonames.ipynb'>Знакомство с geonames и загрузка в postgres, объединение данных в датафрейм</a></li>

 <h3>Этап 2</h3>
<li><a href='https://github.com/pilgblog/project_work/blob/main/сопоставление%20гео%20названий%20с%20унифицированными%20именами%20geonames/Finding_a_solution_geonames.ipynb'>Тестирование моделей и поиск решения</a></li>

<h3>Этап 3</h3>
<li><a href='https://github.com/pilgblog/project_work/blob/main/сопоставление%20гео%20названий%20с%20унифицированными%20именами%20geonames/test_my_model_geonames.ipynb'>Тестирование модели на тестовом датафрейме</a></li>

## Инструменты:
SQL, Pandas, NLP, Transformers

## Вывод:
#### На I этапе:
<br>Мы изучили данные cities15000, admin. countryInfo. Так как в cities15000 были данные альтернативных названий городов, мы не брали файл alternames. После обработки, данные загрузили в базу postgres, затем с помощью запроса к базе geonames сохранили датасеты в тетрадке jypiter, и с помощью pandas объединили датафреймы по code и country_code. В результате получился датафрейм с 9 колонками и со строками в количестве 20731.</br> 
#### На II этапе:
<br>Так как наш датасет имеет опучатки в названиях городов, например вместо Москва - ['Mocva'] или Тамбов - ['Tombof'], мы создали два небольших списка с опечатками на русском и английском языках.</br>
<br>Для TF-IDF. Расстояния Левенштейна, Манхэттенского и Евклидово расстояния, требовалась дополнительная транслятирация, так же мы сделали вывод что эти модели плохо улавливают семантическое сходство. </br>
 <br>В нашем исследовании мы так же использовали фреймворк SentenceTransformer двух многоязычных версий, которые поддерживают 50 языков. Лучше всего с опечатками в тексте справилась модель версии универсального кодировщика предложений с расширенными знаниями. Он верно вывел на первое место скор по названию соответсвующего города. 
 Так же мы использовали поиск сходства по Faiss. Здесь мы использовали косинусное сходство и многоязычную модель SentenceTransformer.</br>
 <br>Для дальнейшей работы, так как у насч небольшой датасет, мы выбрали модель SentenceTranformer версии distiluse-base-multilingual-cased-v2 пакета Huggingface Transformers.</br>
#### На III этапе:
<br>Протестировали модель SentenceTranformer на датасете. По запросу получили соотевтсвующее название города на соответсвующем языке данной страны. Затем для реализации задачи проекта, мы написали функцию для получения вектора и создали столбец embeddings с векторным представлением. После обучения создали функцию для реализации модели, в которой указали словарбь с выводом на печать по запросу.</br>
 <br>Наша функция отлично справилась, так же мы указали дополнительные параметры для определения нужного города, такие как название страны, код страны, регион, количество населения и скор. На случай, если есть одинаковые названия двух городов например в разных регионов или странах.</br>
 <br>Нашу функцию мы реализовали и теперь с ней можно работать. :white_check_mark: Задача проекта выполнена успешно.</br>

